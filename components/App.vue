<template>
  <div>
    <div id="container_pehomu"></div>
    <div class="instructions">[Drag with mouse to move/rotate; mouse wheel to zoom; right-drag to pan]</div>
  </div>
</template>

<script>
import * as THREE from 'three'
import * as d3 from 'd3'
import * as topojson from "topojson-client";
import us from "~/static/counties-albers-10m.json"
import merged_cases from "~/static/merged_data_case.json"

export default {
  mounted() {
    let container, stats;

    let camera, scene, renderer;

    let group;

    let targetRotation = 0;
    let targetRotationOnPointerDown = 0;

    let pointerX = 0;
    let pointerXOnPointerDown = 0;

    let windowHalfX = window.innerWidth / 2;
    
    // let colors = d3.schemeOrRd[7].slice(0, 4).reverse();
    let colors = ["#e31a1c", "#feb24c", "#ffeda0"].reverse();

    init();
    animate();

    function init() {

        container = d3.select("#container_pehomu");
        // document.body.appendChild( container );

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xf0f0f0 );

        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.set( 0, 150, 500 );
        scene.add( camera );

        const light = new THREE.PointLight( 0xffffff, 0.8 );
        camera.add( light );

        group = new THREE.Group();
        group.position.y = 30;
        scene.add( group );

        // const loader = new THREE.TextureLoader();
        // const texture = loader.load( "textures/uv_grid_opengl.jpg" );

        // // it's necessary to apply these settings in order to correctly display the texture on a shape geometry

        // texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        // texture.repeat.set( 0.008, 0.008 );

        function addShape( shape, extrudeSettings, color, opacity, x, y, z, rx, ry, rz, s ) {

            // flat shape with texture
            // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices

            // let geometry = new THREE.ShapeGeometry( shape );

            // // let mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: texture } ) );
            // let mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide } ) );
            // mesh.position.set( x, y, z - 175 );
            // mesh.rotation.set( rx, ry, rz );
            // mesh.scale.set( s, s, s );
            // group.add( mesh );

            // // flat shape

            // geometry = new THREE.ShapeGeometry( shape );

            // mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color, side: THREE.DoubleSide } ) );
            // mesh.position.set( x, y, z - 125 );
            // mesh.rotation.set( rx, ry, rz );
            // mesh.scale.set( s, s, s );
            // group.add( mesh );

            // extruded shape

            let geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

            let mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: color, transparent: true, opacity: opacity } ) );
            mesh.position.set( x, y, z );
            mesh.rotation.set( rx, ry, rz );
            mesh.scale.set( s, s, s );
            group.add( mesh );

            // addLineShape( shape, color, x, y, z, rx, ry, rz, s );

        }

        function addLineShape( shape, color, x, y, z, rx, ry, rz, s ) {
            // solid line
            const points = shape.getPoints();
            const geometryPoints = new THREE.BufferGeometry().setFromPoints( points );

            let line = new THREE.Line( geometryPoints, new THREE.LineBasicMaterial( { color: color } ) );
            line.position.set( x, y, z );
            line.rotation.set( rx, ry, rz );
            line.scale.set( s, s, s );
            group.add( line );
        }

        var grp_levels = ["low", "med", "high"];
        var all_ts = Object.keys(merged_cases);
        console.log(all_ts);
        for ( let t_ind = all_ts.length - 1; t_ind >= 0; t_ind--) {
            var t = all_ts[t_ind];
            
            for ( let grp_ind = 1; grp_ind < 3; grp_ind++) {
                var extrudeSettings = { depth: 4 - 0.1 * (2 - grp_ind), bevelEnabled: false, bevelSegments: 0, steps: 2, bevelSize: 0, bevelThickness: 0 };
                var grp_level = grp_levels[grp_ind];
                if (merged_cases[t][grp_level].length > 0) {
                    var polys = merged_cases[t][grp_level][0].geometry.coordinates;
                    for ( let poly = 0; poly < polys.length; poly++) {
                        let ptsRaw = polys[poly];
                        if (merged_cases[t][grp_level][0].geometry.type === "MultiPolygon") {
                            ptsRaw = ptsRaw[0];
                        }
                        let pts = [];
                        for ( let i = 0; i < ptsRaw.length; i++) {
                            pts.push( new THREE.Vector2( ptsRaw[i][0] - 487.5, -1 * ptsRaw[i][1] + 605 ) );
                            pts[i].multiplyScalar( 0.45 );
                        }
                        addShape(
                            new THREE.Shape(pts),
                            extrudeSettings,
                            colors[grp_ind], 0.25 * grp_ind, 0, 0, -200 + t_ind * 4 + (2 - grp_ind) * 0.05, 0, 0, 0, 1
                        );
                    }
                }
            }
        }


        var states = topojson.feature(us, us.objects.states).features;
        for ( let state in states ) {
            let polys = states[state].geometry.coordinates;
            for ( let poly = 0; poly < polys.length; poly++) {
                let ptsRaw = polys[poly];
                if (states[state].geometry.type === "MultiPolygon") {
                    ptsRaw = ptsRaw[0];
                }
                let pts = [];
                for ( let i = 0; i < ptsRaw.length; i++) {
                    pts.push( new THREE.Vector2( ptsRaw[i][0] - 487.5, -1 * ptsRaw[i][1] + 610 ) );
                    pts[i].multiplyScalar( 0.45 );
                }
                for ( let t_ind = 0; t_ind < all_ts.length; t_ind++) {
                    var t_val = all_ts[t_ind];
                    var day_num = parseInt(t_val.substring(8));
                    var month_num = parseInt(t_val.substring(5,7));
                    if (day_num <= 7 && month_num % 2 == 1) {
                        addLineShape(
                            new THREE.Shape(pts),
                            "#000000",
                            0, 0, -200 + t_ind * 4,
                            0, 0, 0, 1
                        );
                    }
                }
            }
        }

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        // container.appendChild( renderer.domElement );
        container.append( () => renderer.domElement );

        container.style.touchAction = 'none';
        container.on( 'pointerdown', onPointerDown );
        // container.addEventListener( 'pointerdown', onPointerDown );

        //

        window.addEventListener( 'resize', onWindowResize );

    }

    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    //

    function onPointerDown( event ) {

        if ( event.isPrimary === false ) return;

        pointerXOnPointerDown = event.clientX - windowHalfX;
        targetRotationOnPointerDown = targetRotation;

        document.addEventListener( 'pointermove', onPointerMove );
        document.addEventListener( 'pointerup', onPointerUp );

    }

    function onPointerMove( event ) {

        if ( event.isPrimary === false ) return;

        pointerX = event.clientX - windowHalfX;

        targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;

    }

    function onPointerUp() {

        if ( event.isPrimary === false ) return;

        document.removeEventListener( 'pointermove', onPointerMove );
        document.removeEventListener( 'pointerup', onPointerUp );

    }

    //

    function animate() {

        requestAnimationFrame( animate );

        render();
        // stats.update();

    }

    function render() {

        group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
        renderer.render( scene, camera );

    }
  }
}
</script>

<style>
body {
  /* font-family: Arial; */
  margin: auto;
  position: relative;
  padding: 20px;
  height: 100%;
  background-color: #fff;
}

form {
  position: absolute;
  right: 10px;
  top: 10px;
}

.node {
  border: solid 1px white;
  line-height: 0.95;
  overflow: hidden;
  position: absolute;
  border-radius: 6px;

  /* background-image: -webkit-linear-gradient(top, hsla(0, 0%, 100%, 0.3), hsla(0, 0%, 100%, 0));
  background-image: -moz-linear-gradient(top, hsla(0, 0%, 100%, 0.3), hsla(0, 0%, 100%, 0));
  background-image: -ms-linear-gradient(top, hsla(0, 0%, 100%, 0.3), hsla(0, 0%, 100%, 0));
  background-image: -o-linear-gradient(top, hsla(0, 0%, 100%, 0.3), hsla(0, 0%, 100%, 0));
  background-image: linear-gradient(top, hsla(0, 0%, 100%, 0.3), hsla(0, 0%, 100%, 0)); */

  /* text-shadow:
    -1px -1px 2px hsla(0, 0%, 100%, 0.25),
    -1px -1px 2px hsla(0, 0%, 100%, 0.25),
    -1px 1px 2px hsla(0, 0%, 100%, 0.25),
    1px -1px 2px hsla(0, 0%, 100%, 0.25),
    -1px 0px 2px hsla(0, 0%, 100%, 0.25),
    1px 0px 2px hsla(0, 0%, 100%, 0.25); */
}

.node div {
  padding: 6px 4%;
}

.controls {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 20;
}

.controls button {
  width: 100px;
  height: 20px;
  margin: 1px;
  cursor: pointer;
  font-size: 11px;
  color: #333;
  border-radius: 2px;
  background-color: #fff;
  border: 1px solid #999;
}

.instructions {
  position: relative;
  color: #000;
  left: 30px;
  top: 460px;
  z-index: 10;
  font-size: 11px;
  width: 400px;
}
</style>